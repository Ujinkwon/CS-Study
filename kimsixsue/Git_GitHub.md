- [Git 그리고 GitHub](#Git-그리고-GitHub)
  * [1. 시작하기](#1.-시작하기)
    + [Version Control System](#version-control-system)
    + [DVCS 분산 버전 관리 시스템](#DVCS-분산-버전-관리-시스템)
    + [Git의 역사](#Git의-역사)
    + [CLI](#cli)
    + [Git 기초](#Git-기초)
  * [2. Git의 기초](#2. Git의-기초)
    + [Git 최초 설정](#Git-최초-설정)
    + [Git 저장소 만들기](#Git-저장소-만들기)
    + [수정하고 저장소에 저장하기](#수정하고-저장소에-저장하기)
    + [리모트 저장소](#리모트-저장소)
  * [3. Git 브랜치](#3. Git-브랜치)
  * [4. 분산 환경에서의 Git](#4.-분산-환경에서의-Git)
    + [분산 환경에서의 워크플로](#분산-환경에서의-워크플로)
      - [Integration-Manager 워크플로](#Integration-Manager-워크플로)
    + [프로젝트에 기여하기](#프로젝트에-기여하기)
      - [커밋 가이드라인](#커밋-가이드라인)
  * [5. Git 서버](#5.-Git-서버)
  * [6. [GitHub](https://github.com/)](#6--github--https---githubcom--)
    + [[계정 만들고](https://github.com/signup?source=login) 설정하기](#[계정 만들고](https://github.com/signup?source=login) 설정하기)
    + [GitHub 프로젝트에 기여하기](#GitHub-프로젝트에-기여하기)
      - [프로젝트 Fork 하기](#프로젝트-Fork-하기)
      - [GitHub 플로우](#GitHub-플로우)
      - [코드 조각](#코드-조각)
    + [GitHub 프로젝트 관리하기](#GitHub-프로젝트-관리하기)
      - [[새 저장소 만들기](https://github.com/new)](#[새 저장소 만들기](https://github.com/new))
    + [[알림 페이지](https://github.com/settings/notifications)](#[알림 페이지](https://github.com/settings/notifications))
      - [[웹 알림](https://github.com/notifications)](#[웹 알림](https://github.com/notifications))
      - [이메일 알림](#이메일-알림)
    + [특별한 파일](#특별한-파일)
      - [README](#readme)
  * [7. Git 도구](#7.-Git-도구)
    + [Stashing](#stashing)
  * [부록: Git 명령어](#부록:-Git-명령어)
    + [프로젝트 가져오기와 생성하기](#프로젝트-가져오기와-생성하기)
    + [스냅샷 다루기](#스냅샷-다루기)
    + [Branch와 Merge](#Branch와-Merge)
    + [공유하고 업데이트하기](#공유하고-업데이트하기)
  * [공식 페이지](#공식-페이지)

# Git 그리고 GitHub

## 1. 시작하기

### Version Control System

**파일** 변화를 기록했다가, 특정 시점을 불러올 수 있는 시스템이다. 파일이나 프로젝트를 쉽게 **복구**할 수 있고, 수정 내용을 비교해 볼 수 있고, 누가 언제 무엇을 했는지도 알 수 있다. 

### DVCS 분산 버전 관리 시스템

DVCS인 Git은 저장소를 히스토리와 더불어 전부 **복제**한다. **Clone**은 모든 데이터를 가진 진정한 백업이다. 서버나 클라이언트 중에 문제가 생겨도 **복원**할 수 있다.

대부분의 DVCS 환경에는 리모트 저장소가 존재한다. 때문에 동시에 다양한 그룹과 다양하게 **협업**할 수 있다.

### Git의 역사

**Linux** 측은 2002년 Bitkeeper라는 DVCS를 쓰기 시작했다. 2005년 무료 사용이 아니게 되면서, 리눅스 토발즈는 **Git**을 만들었다. **초기 세운 목표**는 단순한 구조, 완벽한 분산, 비선형적인 개발(동시다발적인 브랜치), 빠른 속도, 대형 프로젝트에 유용할 것(속도나 데이터 크기 면에서)이었다.

### CLI

CLI는 Git의 **모든** 기능을 지원한다. GUI는 Git의 일부 기능만 구현한다.

### Git 기초

- 파일이 달라지지 않았으면 Git은 성능을 위해서 파일을 새로 저장하지 않는다. 단지 이전 **상태**의 파일에 대한 링크만 저장한다.

- 로컬에서 실행하기 때문에 명령이 **빠르다**. **로컬** 저장소기 때문에 로컬에서 커밋할 수도 있다. 

- Git으로 무엇을 하든 Git DB에 데이터가 **추가** 된다. 일단 **커밋**하고 나면 데이터를 잃어버리기 어렵다.

- 상태
  
  - Committed: 로컬 DB에 데이터가 안전하게 **저장**됨
  
  - Modified: **수정**한 파일을 아직 로컬 DB에 커밋하지 않음
  
  - Staged: 현재 수정한 파일을 곧 커밋할 것이라고 **표시**

- 단계
  
  - Working Tree(directory): 프로젝트의 특정 **버전**을 Checkout 한 것이다. 파일을 수정한다.
  
  - Index(Staging Area): 곧 **커밋할** 파일에 대한 정보를 저장한다. Stage해서 파일을 추가할 수 있고, Repository에 저장한다.
  
  - Repository(.git directory): Clone 시 만들어지는 **저장소**이다.

- 저장소에 있는 파일들은 Comitted이다. Index에 추가하기 전, 수정했다면 Modified이다. 수정 후 Index에 추가하면 Staged이다. 

## 2. Git의 기초

### Git 최초 설정

**Git을 설치**하고 나서 가장 먼저 해야 하는 것이다. Git은 커밋할 때마다 이 정보를 사용한다. 한 번 커밋한 후에는 정보를 변경할 수 없다.

다시 말하자면 `--global` 옵션으로 설정하는 것은 딱 **한 번만** 하면 된다. 해당 시스템에서 해당 사용자가 사용할 때는 이 정보를 사용한다. 만약 프로젝트마다 다른 이름과 이메일 주소를 사용하고 싶으면 `--global` 옵션을 빼고 명령을 실행한다.

```console
$ git config --global user.name "John Doe"
$ git config --global user.email johndoe@example.com
```

`git config --list` 명령을 실행하면 설정한 모든 것을 보여주어 바로 확인할 수 있다.

### Git 저장소 만들기

1. **기존 디렉토리**를 Git 저장소를 적용하여, Git 저장소로 만든다.
   
   `.git` 이라는 하위 디렉토리를 만든다. `.git` 디렉토리에는 저장소에 필요한 Skeleton이 들어 있다. Git이 파일을 관리하게 하려면 저장소에 파일을 추가하고 커밋해야 한다.
   
   ```console
   $ git add *
   $ git commit -m 'initial project version'
   ```

2. `git clone <url>` 명령으로 다른 곳에서 **기존 저장소를 Clone**해서 Git 저장소를 쓰기 시작한다.

### 수정하고 저장소에 저장하기

* `git add` 로 파일을 새로 추적할 수 있다.

* `git commit` 을 실행하여 커밋한다.

* `git status` 로 파일의 **상태**를 확인할 수 있다.
- `git log` 저장소의 **히스토리**를 조회한다.

- `git diff` 로 어떤 라인을 추가했고 삭제했는지 알 수 있다.

- 필요없는 파일을 무시하려면, `.gitignore` 파일을 만들고 그 안에 무시할 패턴을 적는다. 보통 처음에 만들어 두는 것이 편리하다.

### 리모트 저장소

- `git remote` 로 현재 프로젝트에 등록된 리모트 저장소를 확인할 수 있다. `git remote add <단축이름> <url>`로 기존 워킹 디렉토리에 새 리모트 저장소를 **추가**할 수 있다.

- `git pull` 로 리모트 저장소 브랜치에서 **데이터를 가져올** 뿐만 아니라, 자동으로 현재 작업하는 코드와 Merge 시킨다.

- `git push <리모트 저장소 이름> <브랜치 이름>`로 서버에 Push 한다.

## 3. Git 브랜치

- **브랜치**란 코드를 통째로 복사하고 나서 원래 코드와는 상관없이 독립적으로 개발하는 것이다. Git의 브랜치는 커밋 사이를 가볍게 이동할 수 있는 포인터 같은 것이다. 

- `git init` 명령으로 초기화할 때, **`master` 브랜치**가 자동으로 만들어진다. 

- `git clone` 명령이 자동으로 **리모트 이름**을 “**origin**”으로 만들어준다.


## 4. 분산 환경에서의 Git

### 분산 환경에서의 워크플로

모든 개발자는 다른 개발자의 저장소에 일한 내용을 **전송**하거나, 다른 개발자들이 참여할 수 있도록 자신이 운영하는 저장소 위치를 **공개**할 수도 있다.

중앙집중식 워크플로, **Integration-Manager 워크플로**, Dictator and Lieutenants 워크플로를 주로 이용한다.

#### Integration-Manager 워크플로

다른 개발자는 읽기만 가능하고 자신은 쓰기도 가능한 공개 저장소를 만든다. 이 Workflow에는 보통 프로젝트를 대표하는 공식 저장소가 있다. 

1. 프로젝트 Integration-Manager는 프로젝트 메인 저장소에 **Push**를 한다.

2. 프로젝트 기여자는 메인 저장소를 **Clone** 하고 수정한다.

3. 기여자는 자신의 저장소에 **Push** 하고 Integration-Manager가 접근할 수 있도록 공개해 놓는다.

4. 기여자는 프로젝트 Integration-Manager에게 새 저장소에서 **Pull 하라고 요청**한다.

5. Integration-Manager는 기여자의 저장소를 리모트 저장소로 등록하고 , 로컬에서 기여물을 테스트하고, 프로젝트 메인 브랜치에 **Merge** 한다.

6. Integration-Manager는 Merge 한 사항을 프로젝트 메인 저장소에 **Push** 한다.

Hub 사이트를 통해 주로 사용하는 방식이다. 프로젝트를 **Fork** 하고 수정사항을 반영하여 다시 모두에게 공개하기 좋은 구조로 돼 있다. 

이 방식의 장점은 기여자와 Integration-Manager가 각자의 사정에 맞춰 프로젝트를 유지할 수 있다는 점이다. 기여자는 자신의 저장소와 브랜치에서 수정 작업을 계속해 나갈 수 있고 수정사항이 프로젝트에 반영되도록 기다릴 필요가 없다. 관리자는 여유를 가지고 기여자가 Push 해 놓은 커밋을 적절한 시점에 Merge 한다.

### 프로젝트에 기여하기

#### 커밋 가이드라인

- 무엇보다도 먼저 **공백문자**를 깨끗하게 정리하고 커밋해야 한다.

- 각 커밋은 논리적으로 구분되는 Changeset이다. 최대한 수정사항을 **한 주제로 요약**할 수 있어야 하고 여러 가지 이슈에 대한 수정사항을 하나의 커밋에 담지 않아야 한다. **작업 내용을 분할**하고, 각 커밋마다 적절한 메시지를 작성한다.

- **현재형** 표현을 사용하는 것이 좋다. **명령문**으로 시작하는 것도 좋은 방법이다.
  
  ```console
  Add tests for (테스트 추가) 와 같은 메시지를 작성한다.
  remove invalid default value
  add reset task
  add limit to log function
  add ls-files
  ```

## 5. Git 서버

- [GitLab](https://gitlab.com/)
  
  - DB와 따로 연동해야하는 웹 앱이라 설치하기에 복잡하다.
  
  - 자신의 서버에서 Git 서버를 운영하면 제어 범위가 넓어지고 방화벽 등을 운영할 수 있다. 하지만 설정하고 유지보수하는 데에 시간이 많이 든다.

- [GitHub](https://github.com/)
  
  - Git 서버를 직접 운영하지 않으려면 골라야하는 가장 큰 Git **호스팅** 서비스이다.
  
  - 호스팅 서비스를 이용하면 설정과 유지보수가 쉬워진다. 대신 코드를 외부에 두게 된다. 자신의 회사나 조직에서 이를 허용하는지 사용하기 전에 확인해야 한다.

## 6. [GitHub](https://github.com/)

GitHub은 **가장 큰** Git 저장소 호스트이다. 수백만 개발자가 모여서 수백만 프로젝트를 수행하는 중추다. Git 저장소를 GitHub에 만들어 운영하는 비율이 높다. 많은 오픈 소스 프로젝트는 GitHub을 이용해서 Git 호스팅, 이슈 트래킹, 코드 리뷰 등등의 일을 한다. Git을 많이 사용하다 보면 Git 프로젝트 자체에는 참여하지 않더라도 GitHub을 꼭 써야 하는 상황이 오거나 스스로 쓰고 싶어질 것이다.

### [계정 만들고](https://github.com/signup?source=login) 설정하기

무료 계정도 GitHub 기능을 전부 사용할 수 있다. 딱 한 가지 제약이 있는데 모든 사람이 읽을 수 있는 **공개 프로젝트만** 만들 수 있다. GitHub에 돈을 내면 비공개 프로젝트도 만들 수 있다.

GitHub는 Git 커밋에 있는 이메일 주소를 보고 어떤 사용자인지 식별한다. 사용자가 이메일 주소를 여러 개 사용해서 커밋했어도 GitHub에 그 이메일을 모두 등록하기만 했으면 GitHub는 잘 처리한다. “[Emails](https://github.com/settings/emails)” 화면에서 모두 등록한다.

### GitHub 프로젝트에 기여하기

#### 프로젝트 Fork 하기

GitHub에서 “Fork” 는 단순히 자신의 네임스페이스로 **복사**하는 것을 뜻한다. 그래서 공개한 상태로 수정하고 좀 더 열린 방식으로 참여할 수 있다. 

“Fork” 하면 GitHub이 프로젝트를 통째로 복사해준다. 그 복사본은 사용자 네임스페이스에 있고 **Push** 할 수도 있다. 그리고 Push 한 변경 내용을 원래 저장소로 보내 기여한다. 

**토론 스레드**를 만들고 거기서 코드 리뷰를 하면서 토론하는 스레드를 만들어 토론을 시작한다. 프로젝트 소유자 마음에 들 때까지 소유자와 기여자는 함께 토론한다. 마음에 들게 되면 Merge 한다.

#### GitHub 플로우

GitHub은 **Pull Request**가 중심인 협업 워크플로를 위주로 설계됐다.

이 워크플로는 **Fork** 해서 프로젝트에 기여하는 것인데 유용하다.

1. 프로젝트를 `Fork` 한다.

2. `master` 기반으로 토픽 브랜치를 만든다.

3. 뭔가 수정해서 커밋한다.

4. 자신의 GitHub 프로젝트에 브랜치를 Push 한다.

5. GitHub에 Pull Request를 생성한다.

6. 토론하면서 그에 따라 계속 커밋한다.

7. 프로젝트 소유자는 Pull Request를 Merge 하고 닫는다.

이 방식은 기본적으로 Integration-Manager 워크플로와 같다. **토론이나 리뷰**를 이메일이 아니라 GitHub에서 제공하는 웹 기반 도구를 사용하는 것뿐이다.

#### 코드 조각

코멘트에 코드 조각도 넣을 수 있다. 실제로 구현해서 브랜치에 커밋하기 전에 뭔가 아이디어를 코드로 표현해 볼 때 좋다. 그 외에도 단순히 코드 예제를 보여주기 위해서 사용하거나 해당 Pull Request에서 구현한 것이 무엇인지 보여줄 때도 사용한다.

백틱으로 된 “Fence” 안에 코드 조각을 넣는다.

코드 조각에 언어 이름을 쓰면 GitHub은 구문강조(Syntax Highlight)도 해준다. 구문강조로 미끈해진 코드는 언어 이름을 넣어서 구문 강조된 결과다.

```text
```java
for(int i=0 ; i < 5 ; i++)
{
   System.out.println("i is : " + i);
}
```

### GitHub 프로젝트 관리하기

#### [새 저장소 만들기](https://github.com/new)

**프로젝트 이름**을 넣는 것만 필수다. 다른 것은 생략해도 된다. “Create Repository” 버튼을 클릭하면 `<user>/<project_name>` 위치에 GitHub 저장소가 생긴다.

GitHub에 프로젝트를 올렸으면 다른 사람들에게 프로젝트 URL을 알려주고 공유할 수 있다. 모든 프로젝트의 HTTPS URL은 `https://github.com/<user>/<project_name>`처럼 생겼다.

GitHub **계정 없이** Clone 할 수 있기 때문에 공개 프로젝트를 공유할 때는 HTTP URL를 공유한다. 브라우저에서 프로젝트 페이지에 접속할 때도 저장소 URL로 사용하는 HTTP URL을 그대로 사용한다.

### [알림 페이지](https://github.com/settings/notifications)

GitHub의 “알림” 은 프로젝트에서 어떤 일이 일어나면 바로 알 수 있도록 안내해 주는 것이다. 이 알림은 원하는 방법으로 설정해 쓸 수 있다. 설정의 “**Notification**” 탭에 가면 설정할 수 있는 옵션이 있다.

알림을 이메일로 받을지 웹으로 받을지 **선택**할 수 있다. 물론 두 가지 방법을 동시에 사용해도 된다. 그리고 그냥 대화에 참여하는 경우와 프로젝트를 'Watching' 하는 경우를 나누어 선택할 수 있다.

#### [웹 알림](https://github.com/notifications)

웹 알림은 GitHub에서 제공하는 것으로 GitHub 사이트에서만 확인할 수 있다. 이 옵션을 선택하면 알림이 오면 **알림 아이콘에 파란 점**을 볼 수 있다. 

알림 아이콘을 클릭하면 알림 메시지를 확인할 수 있다. 알림은 **프로젝트별**로 분류된다. 왼쪽 메뉴에 있는 프로젝트를 선택하면 관련 알림만 걸러서 볼 수 있다. 각 알림에 있는 체크박스를 클릭해서 읽었다고 표시를 할 수 있고 제일 위에 있는 체크박스를 클릭하면 해당 알림에 대해서 전부 읽음 표시를 할 수 있다. 그리고 'Mute' 버튼을 클릭하면 해당 사항에 대해서는 더는 알림이 오지 않는다.

이 기능을 사용하면 쏟아지는 알림들도 매우 효율적으로 처리할 수 있다. GitHub의 파워 유저는 이메일 알림을 꺼놓고 GitHub 사이트에서만 알림을 관리하기도 한다.

#### 이메일 알림

이메일 알림을 켜 놓으면 이메일로도 GitHub 알림을 확인할 수 있다.

`List-Unsubscribe` 는 이메일 클라이언트에서 알림을 **그만 받도록** 할 수 있다. 이슈와 Pull Request페이지의 “Unsubscribe” 버튼을 클릭하거나 웹 알림 페이지에서 “Mute” 버튼을 클릭하는 것과 같다.

이메일과 웹 알림이 둘 다 켜져 있으면 알림이 이메일로도 오고 웹으로도 온다. 이메일 클라이언트에서 이미지가 허용되어 있으면, 메일을 읽었을 때 웹에서도 **읽었다고 표시**된다.

### 특별한 파일

#### README

GitHub는 저장소 랜딩 페이지를 보여줄 때 README 파일을 이용해서 보여준다. README 파일 형식에 상관없이 잘 보여준다. `README` 파일이든 `README.md` 파일이든 GitHub가 자동으로 렌더링해서 보여준다.

많은 사람이 이 파일에 저장소나 프로젝트에 **처음 방문한 사람**들에게 필요한 정보를 정리해 둔다. 보통 아래와 같은 내용을 쓴다.

- 무슨 프로젝트인지

- 설정하고 설치하는 방법

- 사용법과 실행 결과에 대한 예제

- 프로젝트의 라이센스

- 기여하는 방법

GitHub는 README 파일을 렌더링하는 것이기 때문에 이미지나 외부 링크를 적어도 된다.

## 7. Git 도구

### Stashing

`git stash` 라는 명령으로 **커밋하지 않을 수 있다**.

Stash 명령을 사용하면 워킹 디렉토리에서 수정한 파일들만 저장한다. Stash는 Modified이면서 Tracked 상태인 파일과 Staging Area에 있는 파일들을 보관해두는 장소다. 

## 부록: Git 명령어

### 프로젝트 가져오기와 생성하기

Git 저장소는 두 가지 방법으로 만든다. 네트워크 어딘가에 있는 저장소를 **복사**해오거나 기존 프로젝트 디렉토리에서 저장소를 새로 **생성**할 수 있다.

프로젝트 디렉토리로 가서 `git init`이라고 실행한다. 디렉토리에 Git 저장소가 **새로** 만들어지고 프로젝트를 버전 관리할 수 있다.

`git clone` 은 사실 **다른 명령어를 몇 개 실행**한다. 디렉토리를 만들고 디렉토리로 들어가고 나서 `git init` 명령으로 빈 Git 저장소를 만든다. 그다음 입력한 URL을 `origin` 이라는(기본값) 이름의 리모트로 추가하고(`git remote add`) 리모트 저장소에서 데이터를 가져온다.

### 스냅샷 다루기

`git add` 명령은 워킹 디렉토리에서 Staging Area(“index”)로 **컨텐트를 추가**하는 명령어다. `git commit` 명령은 오로지 Staging Area만 바라보기 때문에 `git add` 명령으로 커밋할 스냅샷을 잘 다듬어야 한다.

`git status` 명령은 워킹 디렉토리와 Staging Area의 **상태**를 보여준다. Modified 상태이거나 Unstaged 상태인 파일이 무엇인지 Staged 상태이지만 아직 커밋하지 않은 파일은 무엇인지 보여준다. Staging Area에 파일을 넣고 꺼내는 방법에 대한 힌트도 보여준다.

`git diff` 명령은 두 트리 개체의 **차이**를 보고 싶을 때 사용한다. 워킹 디렉토리와 Staging Area를 비교할 수 있다.

`git commit` 명령은 `git add`로 Staging Area에 넣은 모든 파일을 **커밋**한다. 데이터베이스에는 하나의 스냅샷으로 기록된다. 그리고 현 브랜치가 새 커밋을 가리키게 한다.

### Branch와 Merge

`git log` 명령은 프로젝트 히스토리를 시간의 역순으로 보여준다. 넘겨준 Ref를 따라 히스토리를 보여주는데 Ref를 한 개가 아니라 여러 개 넘길 수도 있다. Ref를 넘겨 주지 않으면 HEAD가 가리키는 브랜치의 히스토리를 보여준다. 또 이 명령으로 여러 브랜치들 사이의 **차이를 커밋 단위로 볼 수 있다**.

`git stash` 명령은 아직 **커밋하지 않은** 일을 저장하는 데 사용된다. 작업 중인 워킹 디렉토리를 저장한다.

### 공유하고 업데이트하기

`git pull` 명령은 해당 리모트에서 Fetch 하고 즉시 현 브랜치로 Merge를 시도한다.

`git push` 명령은 리모트에는 없지만, 로컬에는 있는 커밋을 계산하고 나서 **그 차이만큼만** Push 한다. Push를 하려면 원격 저장소에 대한 쓰기 권한이 필요하고 인증돼야 한다.

`git remote` 명령은 원격 저장소 설정인 리모트의 관리 도구다. 이 명령은 `git remote add <name> <url>` 형식으로 사용한다.

## 공식 페이지

[Git - Book](https://git-scm.com/book/ko/v2)

[About · GitHub](https://github.com/about)

[GitHub Documentation](https://docs.github.com/en)

[https://skills.github.com](https://skills.github.com/)
