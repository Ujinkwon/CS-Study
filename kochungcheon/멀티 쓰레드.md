# 멀티 쓰레드





## 개념 

![views](https://wayhome25.github.io/assets/post-img/cs/thread.png)

- 프로세스

​	메모리에 적재되어 CPU 자원을 할당받아 실행되는 프로그램

​	(CPU시간, 주소 공간, 메모리 영역)

 	함수의 매개변수, 복귀 주소, 로컬 변수와 같은 임시 자료를 저장하는 프로세스 스택과 전역 변수들을 저장하는 데이터 섹션, 프로세스 실행 중에 동적으로 할당되는 메모리인 힙을 포함한다. 

PCB는 특정 프로세스에 대한 중요한 정보를 저장하고 있는 운영체제의 자료구조를 말하며, 운영체제는 프로세스의 생성과 동시에 고유한 PCB를 생성하여 프로세스를 관리한다.

- 쓰레드 

​	프로세스의 작업 단위, CPU 수행의 기본 단위, 하나의 쓰레드를 이용하여 한 번에 한 작업만 수행 하면 싱글 쓰레드이다. 프로세스 내에 HEAP, Data, Code 영역을 공유한다. 각각의 쓰레드는 독립적인 작업을 수행 해야하기 때문에 각자의 스택과 PC레지스터 값을 가지고 있음 

- 멀티 쓰레드 

​	하나의 응용프로그램을 여러 개의 프로세스로 구성하여 각 프로세스가 하나의 테스크를 처리하도록 한 것, 여러 쓰레드로 동시에 여러 작업을 수행하면 멀티 쓰레드이다.





## 멀티쓰레드 특징 

![img](https://t1.daumcdn.net/cfile/tistory/995444505AD60F8314)

- 프로세스가 여러 개인 경우 멀티 스레드를 통해서 병렬성을 높일 수 있다. 즉 여러 작업을 동시에 수행할 수 있다. 프로세스의 쓰레드들이 각각 다른 프로세서에서 병렬적으로 수행될 수 있기 때문이다. 병렬성은 CPU 개수에 비한다. 
- 프로세스가 하나인 경우 멀티스레드를 통해서 동시성을 높일 수 있다. 실제로는 각각의 시간에 한 적업만 수행되지만, 병렬적으로 수행되는 것 처럼 보이는 것이다. 만약 한 쓰레드가 waiting되더라도 커널이 다른 스레드로 swith 시켜 실행할 수 있어서, 하나의 프로세서임에도 빠른 처리가 가능하고 계산 속도가 증가한다. 





### 여러 프로세스를 쓰지 않고 쓰레드를 사용하는 이유

- 프로세스를 생성하거나 context switching 하는 작업은 너무 무겁고, 이러한 작업이 많으면 성능 저하가 발생한다.
- 두 프로세스가 하나의 데이터를 공유하려면 메시지 패싱이나 공유 메모리 또는 파이프를 사용해야 하는 데, 이는 효율이 떨어지고 구현과 관리도 번거롭다. 



## 쓰레드의 장점

![img](https://t1.daumcdn.net/cfile/tistory/217D00505822F78905)

- 응답성 

​	싱글 스레드인 경우 작업이 끝나기 전까지 사용자에게 응답하지 않는 다. 멀티쓰레드인 경우 작업을 분리해서 수행하므로 실시간으로 사용자에게 응답할 수 있다. 

- 자원 공유

  프로세스는 오직 공유 메모리나 메시지 패싱을 이용해서 자원을 공유할 수 있지만 쓰레드는 자신이 속한 프로세스 내의 쓰레드들과 메모리나 자원을 공유하며 효율적으로 사용할 수 있다.

- 경제성

  프로세스들을 새로 만드는 비용보다 쓰레드를 새로 생성하는 게 싸다. 그리고 context switching의 오버헤드 또한 쓰레드가 더 경제적이다. Solaris에서 프로세스 생성은 쓰레드 생성보다 30배 느리고, switching은 5배 느리다. 프로세스 내 자원들과 메모리를 공유하기 때문에 메모리 공간과 시스템 자원 소모가 줄어들기 때문이다. 쓰레드 간 통신이 필요한 경우에도 쉽게 데이터를 주고 받을 수 있다.

- 확장성

  싱글 쓰레드인 경우 한 프로세스는 오직 한 프로세서에서만 수행 가능하다. 반면 멀티 쓰레드인 경우 한 프로세서를 여러 프로세서에서 수행할 수 있으므로 훨씬 효율적이다.



## 멀티쓰레드의 단점

- 공유하는 자원에 동시에 접근하는 경우 프로세스와는 달리 쓰레드는 데이터와 힙 영역을 공유하기 때문에 어떤 쓰레드가 다른 쓰레드에서 사용 중인 변수나 자료구조에 접근하여 다른 값을 읽어오거나 수정 할 수 있다. 이를 해결하기 위해서 동기화가 필요하다.
- context switching 동기화 등의 이유 때문에 싱글 코어 멀티 쓰레드는 쓰레드 생성 시간이 오히려 오버헤드로 작용해 단일 쓰레드보다 느리다
-  critical section 동일한 자원을 동시에 접근하는 작업을 실행하는 코드 영역. 쓰레드간에 전역 변수를 공유하므로 함께 사용할 때 충돌이 발생할 수 있다. 동기화가 불필요한 부분까지 되는 경우, 병목 현상을 발생 시켜 성능이 저하될 가능성이 높기 때문에 주의 해야한다. 이를 해결하는 방법에 뮤텍스와 세마포어가 있다.
- 해결책
  - Lock(하드웨어 기반): 동시에 공유자원에 접근하는 것을 막기 위해 Critical section에 진입하는 프로세스는 Lock을 획득하고, Critical section을 빠져나올 때, Lock을 반납한다.
  - Semaphores(소프트웨어 기반)
    - 카운팅 세마포: 가용 자원의 개수로 초기화되어, 자원을 사용할 때마다 세마포가 감소하고, 방출하면 세마포를 증가시킨다.
    - 이진 세마포(Mutual Exclusion): 이진수로 초기화되어, 한 개의 스레드만 접근할 수 있다.
    - Deadlock 문제 발생
      - 스레드/프로세스가 자원을 얻지 못해 다음 처리를 하지 못하는 상태로, ‘교착 상태’라고도 하며 시스템적으로 한정된 자원을 여러 곳에서 사용하려고 할 때 발생한다.
      - 해결책
        - 여러 개의 스레드/프로세스가 공유자원을 이용할 수 있도록 한다.
        - 스레드/프로세스가 실행되기 전 필요한 모든 자원을 할당한다.