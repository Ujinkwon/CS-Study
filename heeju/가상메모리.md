## 가상 메모리

메모리 관리 기법 중 하나로

프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능하도록 하는 기법

1. 사용자 프로그램이 물리 메모리의 제약에서 벗어남
2. 각 프로그램이 더 작은 메모리를 차지하기 때문에 더 많은 프로그램을 동시 수행 가능(한것 처럼 보임)
3. 프로그램을 메모리에 올리고 SWAP하는데 필요한 IO 횟수가 줄어듦



가상 메모리를 이해하기 위해서는?

- 사전배경 지식
  - 컴퓨터 구조
    - 컴퓨터에서 일을 하는 것은 CPU
    - CPU가 연산 
    - CPU가 계산을 하려면 메모리의 값을 참조해야하는데, CPU가 연산을 할때 REGISTER 값을 참조하는데
      - REGISTER: 레지스터는 자료를 보관하는 매우 빠른 기억 장소, 하지만 매우 용량이 작음
      - 그래서 가까운 곳의 레지스터 보다는 MAIN MEMORY를 참고함: 느리지만 더 많은 용량 저장 가능 휘발성 빠름.
  - 프로그램이 실행 되는 것이란?
    - CPU가 일을 하는 것. CPU는 메인메모리 값까지의 값만 참조 가능
    - 따라서 CPU가 일을 하기 위해서는 프로그래밍 정보가 메모리에 올라와야한다.
    - 즉 개발자가 소스코드를 작성하면 > 컴파일러 링커 > 메모리에 참조될수 있는 형태로 변경 > 실행파일 > 실행되면> 물리 메모리에 올라오게 된다. 
    - 실행파일을 실행하면 FORK 요청으로 새 프로세스를 생성하고 프로세스를 EXEC 요청으로 로더를 요청
    - 로더는 새로 생성된 프로세스의 주소공간을 사용하여 지정된 실행 파일을 메모리에 올리는데 사용됨 
  - 주소 바인딩
    - CPU가 실행파일을 실행하면 0번부터 시작하는 프로세스마다 독자적인 주소공간 생성(논리주소)
    - CPU가 바라보는 주소가 논리 주소 공간인데. CPU가 일을 하려면 논리 주소가 메인 메모리 상에 올라와 있어야 한다. 논리 주소가 물리적 메모리의 특정위치로 매핑이 됨. 이 작업을 주소 바인딩 
    - 바인딩 시점에 따라서 논리 주소와 물리주소의 값이 같을 수도 있고 다를수도 있다. 
    - 낮은 주소 영역 0 : CODE > DATA> [HEAP > <STACK]: 높은 주소영역
      - 주소 바인딩 방식 (물리적 메모리 주소가 결정되는 시기에 따라)
        - 컴파일 타임 바인딩
        - 로드 타임 바인딩
        - 실행 시간 바인딩 : 가상 메모리를 사용하기 위해서는 실행시간 바인딩이 지원되야함 
          - 이게 지원이 되면 논리 주소와 물리주소의 값이 달라지게 된다.
          - 실행시간 바인딩을 하기위해서는 하드웨어적인 지원 필요 
          - MMU라는 메모리 관리 장치가 필요함
  - 스왑 영역
    - 여러개의 프로그램이 물리 메모리에 올라오게 되면 공간이 부족하겠죠?
    - 그래서 메모리 공간의 확장영역으로 스왑영역을 사용한다. 
    - 물리 메모리의 확장 개념 실행중인 프로세스 주소공간을 일시적으로 메모리에서 내려 놓는것
    - 프로세스가 수행중인 동안에만 일시적으로 저장 / 상대적으로 빠름 

## 가상메모리

그래서 왜 사용하는데? 

- 여러개의 프로그램을 실행하면 > 물리메모리 많이 사용하게됨> 스왑영역과 IO과 빈번하게 사용됨
- 물리메모리를 벗어나는 프로그램이라면 실행조차 불가능
- 그래서 가상 메모리가 발생함
- 실제의 논리 메모리 개념과 개발자의 논리 메모리 개념을 분리한다. 
- 따라서 가상 메모리를 사용하면 프로세스 전체 내용을 메모리에 올릴필요 없이 필요한 부분만 메모리에 올려 실행이 가능하다. 
- 그럼 어떻게 필요한 정보만 올려 줄 수 있나요? 요구 페이징 기법 

#### 프로세스간의 페이지 공유

가상 메모리는...

- `시스템 라이브러리`가 여러 프로세스들 사이에 공유될 수 있도록 한다. 각 프로세스들은 `공유 라이브러리`를 자신의 가상 주소 공간에 두고 사용하는 것처럼 인식하지만, 라이브러리가 올라가있는 `물리 메모리 페이지`들은 모든 프로세스에 공유되고 있다.
- 프로세스들이 메모리를 공유하는 것을 가능하게 하고, 프로세스들은 공유 메모리를 통해 통신할 수 있다. 이 또한, 각 프로세스들은 각자 자신의 주소 공간처럼 인식하지만, 실제 물리 메모리는 공유되고 있다.
- `fork()`를 통한 프로세스 생성 과정에서 페이지들이 공유되는 것을 가능하게 한다.

### Demand Paging(요구 페이징)

프로그램 실행 시작 시에 프로그램 전체를 디스크에서 물리 메모리에 적재하는 대신, 초기에 필요한 것들만 적재하는 전략을 `요구 페이징`이라 하며, 가상 메모리 시스템에서 많이 사용된다. 그리고 가상 메모리는 대개 [페이지](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/OS#paging페이징)로 관리된다. 요구 페이징을 사용하는 가상 메모리에서는 실행과정에서 필요해질 때 페이지들이 적재된다. **한 번도 접근되지 않은 페이지는 물리 메모리에 적재되지 않는다.**

공간이 페이지 하나가 아니라 여러개의 페이지로 나눠져 있다.

프로세스 내의 개별 페이지들은 `페이저(pager)`에 의해 관리된다. 페이저는 프로세스 실행에 실제 필요한 페이지들만 메모리로 읽어 옮으로써, **사용되지 않을 페이지를 가져오는 시간낭비와 메모리 낭비를 줄일 수 있다.**

#### Page fault trap(페이지 부재 트랩)

### 페이지 교체

`요구 페이징` 에서 언급된대로 프로그램 실행시에 모든 항목이 물리 메모리에 올라오지 않기 때문에, 프로세스의 동작에 필요한 페이지를 요청하는 과정에서 `page fault(페이지 부재)`가 발생하게 되면, 원하는 페이지를 보조저장장치에서 가져오게 된다. 하지만, 만약 물리 메모리가 모두 사용중인 상황이라면, 페이지 교체가 이뤄져야 한다.(또는, 운영체제가 프로세스를 강제 종료하는 방법이 있다.)

#### 기본적인 방법

물리 메모리가 모두 사용중인 상황에서의 메모리 교체 흐름이다.

1. 디스크에서 필요한 페이지의 위치를 찾는다
2. 빈 페이지 프레임을 찾는다.
   1. `페이지 교체 알고리즘`을 통해 희생될(victim) 페이지를 고른다.
   2. 희생될 페이지를 디스크에 기록하고, 관련 페이지 테이블을 수정한다.
3. 새롭게 비워진 페이지 테이블 내 프레임에 새 페이지를 읽어오고, 프레임 테이블을 수정한다.
4. 사용자 프로세스 재시작

#### 페이지 교체 알고리즘

##### FIFO 페이지 교체

가장 간단한 페이지 교체 알고리즘으로 FIFO(first-in first-out)의 흐름을 가진다. 즉, 먼저 물리 메모리에 들어온 페이지 순서대로 페이지 교체 시점에 먼저 나가게 된다는 것이다.

- 장점
  - 이해하기도 쉽고, 프로그램하기도 쉽다.
- 단점
  - 오래된 페이지가 항상 불필요하지 않은 정보를 포함하지 않을 수 있다(초기 변수 등)
  - 처음부터 활발하게 사용되는 페이지를 교체해서 페이지 부재율을 높이는 부작용을 초래할 수 있다.
  - `Belady의 모순`: 페이지를 저장할 수 있는 페이지 프레임의 갯수를 늘려도 되려 페이지 부재가 더 많이 발생하는 모순이 존재한다.

##### 최적 페이지 교체(Optimal Page Replacement)

`Belady의 모순`을 확인한 이후 최적 교체 알고리즘에 대한 탐구가 진행되었고, 모든 알고리즘보다 낮은 페이지 부재율을 보이며 `Belady의 모순`이 발생하지 않는다. 이 알고리즘의 핵심은 `앞으로 가장 오랫동안 사용되지 않을 페이지를 찾아 교체`하는 것이다. 주로 비교 연구 목적을 위해 사용한다.

- 장점
  - 알고리즘 중 가장 낮은 페이지 부재율을 보장한다.
- 단점
  - 구현의 어려움이 있다. 모든 프로세스의 메모리 참조의 계획을 미리 파악할 방법이 없기 때문이다.

##### LRU 페이지 교체(LRU Page Replacement)

`LRU: Least-Recently-Used`
최적 알고리즘의 근사 알고리즘으로, 가장 오랫동안 사용되지 않은 페이지를 선택하여 교체한다.

- 특징
  - 대체적으로 `FIFO 알고리즘`보다 우수하고, `OPT알고리즘`보다는 그렇지 못한 모습을 보인다.

##### LFU 페이지 교체(LFU Page Replacement)

`LFU: Least Frequently Used`
참조 횟수가 가장 적은 페이지를 교체하는 방법이다. 활발하게 사용되는 페이지는 참조 횟수가 많아질 거라는 가정에서 만들어진 알고리즘이다.

- 특징
  - 어떤 프로세스가 특정 페이지를 집중적으로 사용하다, 다른 기능을 사용하게되면 더 이상 사용하지 않아도 계속 메모리에 머물게 되어 초기 가정에 어긋나는 시점이 발생할 수 있다
  - 최적(OPT) 페이지 교체를 제대로 근사하지 못하기 때문에, 잘 쓰이지 않는다.

##### MFU 페이지 교체(MFU Page Replacement)

`MFU: Most Frequently Used`
참조 회수가 가장 작은 페이지가 최근에 메모리에 올라왔고, 앞으로 계속 사용될 것이라는 가정에 기반한다.

- 특징
  - 최적(OPT) 페이지 교체를 제대로 근사하지 못하기 때문에, 잘 쓰이지 않는다.

## 가상메모리의 장점

1. 사용자 프로그램이 물리 메모리의 제약에서 벗어남
2. 각 프로그램이 더 작은 메모리를 차지하기 때문에 더 많은 프로그램을 동시에 수행가능
3. 프로그램을 메모리에 올리고 스왑하는데 필요한 IO 횟수가 줄어듦 